// src/node-to-edge/fetch-event.ts
function buildToFetchEvent(dependencies) {
  return function toFetchEvent(request) {
    const event = new dependencies.FetchEvent(request);
    Object.defineProperty(event, "waitUntil", {
      configurable: false,
      enumerable: true,
      get: () => {
        throw new Error("waitUntil is not supported yet.");
      }
    });
    return event;
  };
}

// src/node-to-edge/headers.ts
function buildToHeaders({ Headers }) {
  return function toHeaders(nodeHeaders) {
    const headers = new Headers();
    for (let [key, value] of Object.entries(nodeHeaders)) {
      const values = Array.isArray(value) ? value : [value];
      for (let v of values) {
        if (v !== void 0) {
          headers.append(key, v);
        }
      }
    }
    return headers;
  };
}

// src/node-to-edge/stream.ts
function buildToReadableStream(dependencies) {
  const { ReadableStream, Uint8Array } = dependencies;
  return function toReadableStream(stream) {
    return new ReadableStream({
      start(controller) {
        stream.on("data", (chunk) => {
          controller.enqueue(new Uint8Array([...new Uint8Array(chunk)]));
        });
        stream.on("end", () => {
          controller.close();
        });
        stream.on("error", (err) => {
          controller.error(err);
        });
      }
    });
  };
}

// src/node-to-edge/request.ts
function buildToRequest(dependencies) {
  const toHeaders = buildToHeaders(dependencies);
  const toReadableStream = buildToReadableStream(dependencies);
  const { Request } = dependencies;
  return function toRequest(request, options) {
    var _a;
    return new Request(
      String(
        new URL(
          request.url || "/",
          computeOrigin(request, options.defaultOrigin)
        )
      ),
      {
        method: request.method,
        headers: toHeaders(request.headers),
        body: !["HEAD", "GET"].includes((_a = request.method) != null ? _a : "") ? toReadableStream(request) : null
      }
    );
  };
}
function computeOrigin({ headers }, defaultOrigin) {
  const authority = headers.host;
  if (!authority) {
    return defaultOrigin;
  }
  const [, port] = authority.split(":");
  return `${port === "443" ? "https" : "http"}://${authority}`;
}

// src/edge-to-node/headers.ts
import { splitCookiesString } from "@edge-runtime/cookies";
function toOutgoingHeaders(headers) {
  var _a, _b;
  const outputHeaders = {};
  if (headers) {
    for (const [name, value] of typeof headers.raw !== "undefined" ? Object.entries(headers.raw()) : headers.entries()) {
      outputHeaders[name] = value;
      if (name.toLowerCase() === "set-cookie") {
        outputHeaders[name] = (_b = (_a = headers.getAll) == null ? void 0 : _a.call(headers, "set-cookie")) != null ? _b : splitCookiesString(value);
      }
    }
  }
  return outputHeaders;
}
function mergeIntoServerResponse(headers, serverResponse) {
  for (const [name, value] of Object.entries(headers)) {
    if (value !== void 0) {
      serverResponse.setHeader(name, value);
    }
  }
}

// src/edge-to-node/stream.ts
import { Readable } from "stream";
function toToReadable(webStream, options = {}) {
  const reader = webStream.getReader();
  let closed = false;
  const { highWaterMark, encoding, objectMode = false, signal } = options;
  const readable = new Readable({
    objectMode,
    highWaterMark,
    encoding,
    // @ts-ignore signal exist only since Node@17
    signal,
    read() {
      reader.read().then(
        (chunk) => {
          if (chunk.done) {
            readable.push(null);
          } else {
            readable.push(chunk.value);
          }
        },
        (error) => readable.destroy(error)
      );
    },
    destroy(error, callback) {
      function done() {
        try {
          callback(error);
        } catch (error2) {
          process.nextTick(() => {
            throw error2;
          });
        }
      }
      if (!closed) {
        reader.cancel(error).then(done, done);
        return;
      }
      done();
    }
  });
  reader.closed.then(
    () => {
      closed = true;
    },
    (error) => {
      closed = true;
      readable.destroy(error);
    }
  );
  return readable;
}

// src/edge-to-node/handler.ts
function buildToNodeHandler(dependencies, options) {
  const toRequest = buildToRequest(dependencies);
  const toFetchEvent = buildToFetchEvent(dependencies);
  return function toNodeHandler(webHandler) {
    return (incomingMessage, serverResponse) => {
      const request = toRequest(incomingMessage, options);
      const maybePromise = webHandler(request, toFetchEvent(request));
      if (maybePromise instanceof Promise) {
        maybePromise.then(
          (response) => toServerResponse(response, serverResponse)
        );
      } else {
        toServerResponse(maybePromise, serverResponse);
      }
    };
  };
}
function toServerResponse(webResponse, serverResponse) {
  if (!webResponse) {
    serverResponse.end();
    return;
  }
  mergeIntoServerResponse(
    // @ts-ignore getAll() is not standard https://fetch.spec.whatwg.org/#headers-class
    toOutgoingHeaders(webResponse.headers),
    serverResponse
  );
  serverResponse.statusCode = webResponse.status;
  serverResponse.statusMessage = webResponse.statusText;
  if (!webResponse.body) {
    serverResponse.end();
    return;
  }
  toToReadable(webResponse.body).pipe(serverResponse);
}
export {
  buildToFetchEvent,
  buildToHeaders,
  buildToNodeHandler,
  buildToReadableStream,
  buildToRequest,
  mergeIntoServerResponse,
  toOutgoingHeaders,
  toToReadable
};
